
import { supabase } from '../config/supabase';
import { Order, OrderItem } from '../types/database.types';
import { freezePrice } from '../utils/currency';

export type OrderStatus = 'pending' | 'confirmed' | 'accepted' | 'purchasing' | 'preparing' | 'ready_for_pickup' | 'picked_up' | 'in_transit' | 'delivered' | 'cancelled';

export async function createOrder(
  customerId: string,
  storeId: string,
  items: { item_id: string; quantity: number }[],
  total: number,
  paymentMethod: 'cash' | 'card' | 'mobile_money' | 'bank_transfer',
  deliveryAddress: string,
  deliveryNotes?: string,
  subtotal?: number,
  deliveryFee?: number,
  tax?: number,
  deliveryLatitude?: number,
  deliveryLongitude?: number,
  customerPhone?: string
): Promise<Order> {
  // Freeze all price values to prevent mutations
  const frozenSubtotal = freezePrice(subtotal || total);
  const frozenDeliveryFee = freezePrice(deliveryFee || 0);
  const frozenTax = freezePrice(tax || 0);
  const frozenTotal = freezePrice(total);

  console.log('Creating order with frozen params:', {
    customerId,
    storeId,
    items,
    frozenTotal,
    paymentMethod,
    deliveryAddress,
    deliveryNotes,
    frozenSubtotal,
    frozenDeliveryFee,
    frozenTax,
    deliveryLatitude,
    deliveryLongitude,
    customerPhone,
  });

  // Create the order (order_number will be auto-generated by trigger)
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .insert({
      customer_id: customerId,
      store_id: storeId,
      status: 'pending',
      subtotal: frozenSubtotal,
      delivery_fee: frozenDeliveryFee,
      tax: frozenTax,
      total: frozenTotal,
      payment_method: paymentMethod,
      payment_status: 'pending',
      delivery_address: deliveryAddress,
      delivery_notes: deliveryNotes,
      delivery_latitude: deliveryLatitude,
      delivery_longitude: deliveryLongitude,
      customer_phone: customerPhone,
    })
    .select()
    .single();

  if (orderError) {
    console.error('Error creating order:', orderError);
    throw orderError;
  }

  console.log('Order created:', order);

  // Get product details for order items
  const productIds = items.map(item => item.item_id);
  const { data: products, error: productsError } = await supabase
    .from('products')
    .select('id, name, price')
    .in('id', productIds);

  if (productsError) {
    console.error('Error fetching products:', productsError);
    throw productsError;
  }

  // Create order items with product details - freeze prices
  const orderItemsData = items.map(item => {
    const product = products?.find(p => p.id === item.item_id);
    const productPrice = freezePrice(product?.price || 0);
    
    return {
      order_id: order.id,
      product_id: item.item_id,
      product_name: product?.name || 'Unknown Product',
      product_price: productPrice,
      quantity: item.quantity,
    };
  });

  const { error: itemsError } = await supabase
    .from('order_items')
    .insert(orderItemsData);

  if (itemsError) {
    console.error('Error creating order items:', itemsError);
    throw itemsError;
  }

  console.log('Order items created');

  // Create chat for the order
  const { error: chatError } = await supabase
    .from('chats')
    .insert({
      order_id: order.id,
      customer_id: customerId,
    });

  if (chatError) {
    console.error('Error creating chat:', chatError);
  }

  return order;
}

export async function getOrderById(orderId: string): Promise<Order> {
  console.log('Fetching order by ID:', orderId);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('id', orderId)
    .single();

  if (error) {
    console.error('Error fetching order by ID:', error);
    throw error;
  }
  
  console.log('Order fetched:', data);
  return data;
}

export async function getOrderItems(orderId: string): Promise<OrderItem[]> {
  console.log('Fetching order items for order:', orderId);
  
  const { data, error } = await supabase
    .from('order_items')
    .select(`
      *,
      item:products(*)
    `)
    .eq('order_id', orderId);

  if (error) {
    console.error('Error fetching order items:', error);
    throw error;
  }
  
  console.log('Order items fetched:', data?.length || 0);
  return data || [];
}

export async function getOrdersByCustomer(customerId: string): Promise<Order[]> {
  console.log('Fetching orders for customer:', customerId);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      store:stores(id, name, address, logo),
      driver:users!orders_driver_id_fkey(id, name, email, phone)
    `)
    .eq('customer_id', customerId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching customer orders:', error);
    throw error;
  }
  
  console.log('Customer orders fetched:', data?.length || 0);
  return data || [];
}

export async function getCustomerOrders(customerId: string): Promise<Order[]> {
  return getOrdersByCustomer(customerId);
}

export async function getDriverOrders(driverId: string): Promise<Order[]> {
  console.log('Fetching orders for driver:', driverId);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('driver_id', driverId)
    .order('created_at', { ascending: false});

  if (error) {
    console.error('Error fetching driver orders:', error);
    throw error;
  }
  
  console.log('Driver orders fetched:', data?.length || 0);
  return data || [];
}

// Alias for consistency
export async function getOrdersByDriver(driverId: string): Promise<Order[]> {
  return getDriverOrders(driverId);
}

export async function getAllOrders(): Promise<Order[]> {
  console.log('Fetching all orders');
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching all orders:', error);
    throw error;
  }
  
  console.log('All orders fetched:', data?.length || 0);
  return data || [];
}

export async function getPendingOrders(): Promise<Order[]> {
  console.log('Fetching pending orders');
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('status', 'pending')
    .is('driver_id', null)
    .order('created_at', { ascending: true });

  if (error) {
    console.error('Error fetching pending orders:', error);
    throw error;
  }
  
  console.log('Pending orders fetched:', data?.length || 0);
  return data || [];
}

export async function assignDriver(orderId: string, driverId: string): Promise<void> {
  console.log('Assigning driver to order:', { orderId, driverId });
  
  // Get order details first
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select('customer_id, order_number')
    .eq('id', orderId)
    .single();

  if (orderError) {
    console.error('Error fetching order:', orderError);
    throw orderError;
  }

  const { error } = await supabase
    .from('orders')
    .update({ 
      driver_id: driverId,
      status: 'accepted',
      confirmed_at: new Date().toISOString(),
    })
    .eq('id', orderId);

  if (error) {
    console.error('Error assigning driver:', error);
    throw error;
  }

  console.log('Driver assigned successfully');

  // Update chat with driver
  const { error: chatError } = await supabase
    .from('chats')
    .update({ driver_id: driverId })
    .eq('order_id', orderId);

  if (chatError) {
    console.error('Error updating chat:', chatError);
  }

  // Broadcast order update
  await supabase.channel(`orders:${orderId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { orderId, status: 'accepted', driverId },
  });
  
  console.log('Order update broadcasted');

  // Send push notification to customer
  try {
    const { notifyOrderStatusChange } = await import('../utils/notifications');
    await notifyOrderStatusChange(
      order.customer_id,
      orderId,
      order.order_number,
      'accepted'
    );
  } catch (notifError) {
    console.error('Error sending notification:', notifError);
  }
}

export async function updateOrderStatus(orderId: string, status: OrderStatus): Promise<void> {
  console.log('Updating order status:', { orderId, status });
  
  // Get order details first
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select('customer_id, order_number, driver_id')
    .eq('id', orderId)
    .single();

  if (orderError) {
    console.error('Error fetching order:', orderError);
    throw orderError;
  }

  const updateData: any = { 
    status,
    updated_at: new Date().toISOString(),
  };

  // Add timestamp fields based on status
  if (status === 'picked_up') {
    updateData.picked_up_at = new Date().toISOString();
  } else if (status === 'delivered') {
    updateData.delivered_at = new Date().toISOString();
  } else if (status === 'cancelled') {
    updateData.cancelled_at = new Date().toISOString();
  }

  const { error } = await supabase
    .from('orders')
    .update(updateData)
    .eq('id', orderId);

  if (error) {
    console.error('Error updating order status:', error);
    throw error;
  }

  console.log('Order status updated successfully');

  // Broadcast order update
  await supabase.channel(`orders:${orderId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { orderId, status },
  });
  
  console.log('Order update broadcasted');

  // Send push notification to customer
  try {
    const { notifyOrderStatusChange } = await import('../utils/notifications');
    await notifyOrderStatusChange(
      order.customer_id,
      orderId,
      order.order_number,
      status
    );
  } catch (notifError) {
    console.error('Error sending notification:', notifError);
  }
}

// Cancel order by driver - resets to pending
export async function cancelOrderByDriver(orderId: string): Promise<void> {
  console.log('Driver cancelling order:', orderId);
  
  const { error } = await supabase
    .from('orders')
    .update({ 
      driver_id: null,
      status: 'pending',
      updated_at: new Date().toISOString(),
    })
    .eq('id', orderId);

  if (error) {
    console.error('Error cancelling order:', error);
    throw error;
  }

  console.log('Order cancelled and reset to pending');

  // Broadcast order update
  await supabase.channel(`orders:${orderId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { orderId, status: 'pending', driverId: null },
  });
}

// Search orders by order number, customer name, or address
export async function searchOrders(query: string): Promise<Order[]> {
  console.log('Searching orders with query:', query);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .or(`order_number.ilike.%${query}%,delivery_address.ilike.%${query}%`)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error searching orders:', error);
    throw error;
  }
  
  console.log('Search results:', data?.length || 0);
  return data || [];
}

// Filter orders by status
export async function filterOrdersByStatus(status: OrderStatus): Promise<Order[]> {
  console.log('Filtering orders by status:', status);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('status', status)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error filtering orders:', error);
    throw error;
  }
  
  console.log('Filtered orders:', data?.length || 0);
  return data || [];
}
