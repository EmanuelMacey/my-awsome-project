
import { supabase } from '../config/supabase';
import { Order, OrderItem } from '../types/database.types';
import { freezePrice } from '../utils/currency';
import AsyncStorage from '@react-native-async-storage/async-storage';

export type OrderStatus = 'pending' | 'confirmed' | 'accepted' | 'purchasing' | 'preparing' | 'ready_for_pickup' | 'picked_up' | 'in_transit' | 'delivered' | 'cancelled';

/**
 * Extract the actual product UUID from a cart item ID
 * Cart items with size options have IDs like "uuid_12oz"
 * We need to extract just the UUID part
 */
function extractProductId(cartItemId: string): string {
  // If the ID contains an underscore, it's a variant (e.g., "uuid_12oz")
  // Extract just the UUID part (everything before the first underscore)
  if (cartItemId.includes('_')) {
    const parts = cartItemId.split('_');
    return parts[0];
  }
  // Otherwise, it's already a pure UUID
  return cartItemId;
}

export async function createOrder(
  customerId: string,
  storeId: string,
  items: { item_id: string; quantity: number }[],
  total: number,
  paymentMethod: 'cash' | 'card' | 'mobile_money' | 'bank_transfer',
  deliveryAddress: string,
  deliveryNotes?: string,
  subtotal?: number,
  deliveryFee?: number,
  tax?: number,
  deliveryLatitude?: number,
  deliveryLongitude?: number,
  customerPhone?: string,
  serviceFee?: number
): Promise<Order> {
  // Freeze all price values to prevent mutations
  const frozenSubtotal = freezePrice(subtotal || total);
  const frozenServiceFee = freezePrice(serviceFee || 200); // Default service fee is 200
  const frozenDeliveryFee = freezePrice(deliveryFee || 0);
  const frozenTax = freezePrice(tax || 0);
  const frozenTotal = freezePrice(total);

  console.log('Creating order with frozen params:', {
    customerId,
    storeId,
    items,
    frozenTotal,
    paymentMethod,
    deliveryAddress,
    deliveryNotes,
    frozenSubtotal,
    frozenServiceFee,
    frozenDeliveryFee,
    frozenTax,
    deliveryLatitude,
    deliveryLongitude,
    customerPhone,
  });

  // Create the order (order_number will be auto-generated by trigger)
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .insert({
      customer_id: customerId,
      store_id: storeId,
      status: 'pending',
      subtotal: frozenSubtotal,
      service_fee: frozenServiceFee,
      delivery_fee: frozenDeliveryFee,
      tax: frozenTax,
      total: frozenTotal,
      payment_method: paymentMethod,
      payment_status: 'pending',
      delivery_address: deliveryAddress,
      delivery_notes: deliveryNotes,
      delivery_latitude: deliveryLatitude,
      delivery_longitude: deliveryLongitude,
      customer_phone: customerPhone,
    })
    .select()
    .single();

  if (orderError) {
    console.error('Error creating order:', orderError);
    throw orderError;
  }

  console.log('Order created:', order);

  // Extract actual product IDs from cart item IDs (remove size suffixes)
  const productIds = items.map(item => extractProductId(item.item_id));
  
  console.log('Extracted product IDs:', productIds);

  // Get product details for order items
  const { data: products, error: productsError } = await supabase
    .from('products')
    .select('id, name, price')
    .in('id', productIds);

  if (productsError) {
    console.error('Error fetching products:', productsError);
    throw productsError;
  }

  console.log('Products fetched:', products?.length || 0);

  // Create order items with product details - freeze prices
  // CRITICAL FIX: Use the extracted product UUID, not the cart item ID
  const orderItemsData = items.map(item => {
    const actualProductId = extractProductId(item.item_id);
    const product = products?.find(p => p.id === actualProductId);
    const productPrice = freezePrice(product?.price || 0);
    
    console.log('Creating order item:', {
      cartItemId: item.item_id,
      extractedProductId: actualProductId,
      productName: product?.name,
      quantity: item.quantity,
    });
    
    return {
      order_id: order.id,
      product_id: actualProductId, // Use the extracted UUID, not the cart item ID
      product_name: product?.name || 'Unknown Product',
      product_price: productPrice,
      quantity: item.quantity,
    };
  });

  const { error: itemsError } = await supabase
    .from('order_items')
    .insert(orderItemsData);

  if (itemsError) {
    console.error('Error creating order items:', itemsError);
    throw itemsError;
  }

  console.log('Order items created successfully');

  // Create chat for the order
  const { error: chatError } = await supabase
    .from('chats')
    .insert({
      order_id: order.id,
      customer_id: customerId,
    });

  if (chatError) {
    console.error('Error creating chat:', chatError);
  }

  // Invalidate customer orders cache
  await AsyncStorage.removeItem(`orders_${customerId}`);
  console.log('ðŸ§¹ Invalidated customer orders cache');

  return order;
}

export async function getOrderById(orderId: string): Promise<Order> {
  console.log('Fetching order by ID:', orderId);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('id', orderId)
    .single();

  if (error) {
    console.error('Error fetching order by ID:', error);
    throw error;
  }
  
  console.log('Order fetched:', data);
  return data;
}

export async function getOrderItems(orderId: string): Promise<OrderItem[]> {
  console.log('Fetching order items for order:', orderId);
  
  const { data, error } = await supabase
    .from('order_items')
    .select(`
      *,
      item:products(*)
    `)
    .eq('order_id', orderId);

  if (error) {
    console.error('Error fetching order items:', error);
    throw error;
  }
  
  console.log('Order items fetched:', data?.length || 0);
  return data || [];
}

export async function getOrdersByCustomer(customerId: string): Promise<Order[]> {
  console.log('Fetching orders for customer:', customerId);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      store:stores(id, name, address, logo),
      driver:users!orders_driver_id_fkey(id, name, email, phone)
    `)
    .eq('customer_id', customerId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching customer orders:', error);
    throw error;
  }
  
  console.log('Customer orders fetched:', data?.length || 0);
  return data || [];
}

export async function getCustomerOrders(customerId: string): Promise<Order[]> {
  return getOrdersByCustomer(customerId);
}

export async function getDriverOrders(driverId: string): Promise<Order[]> {
  console.log('Fetching orders for driver:', driverId);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('driver_id', driverId)
    .order('created_at', { ascending: false});

  if (error) {
    console.error('Error fetching driver orders:', error);
    throw error;
  }
  
  console.log('Driver orders fetched:', data?.length || 0);
  return data || [];
}

// Alias for consistency
export async function getOrdersByDriver(driverId: string): Promise<Order[]> {
  return getDriverOrders(driverId);
}

export async function getAllOrders(): Promise<Order[]> {
  console.log('Fetching all orders');
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching all orders:', error);
    throw error;
  }
  
  console.log('All orders fetched:', data?.length || 0);
  return data || [];
}

export async function getPendingOrders(): Promise<Order[]> {
  console.log('Fetching pending orders');
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('status', 'pending')
    .is('driver_id', null)
    .order('created_at', { ascending: true });

  if (error) {
    console.error('Error fetching pending orders:', error);
    throw error;
  }
  
  console.log('Pending orders fetched:', data?.length || 0);
  return data || [];
}

export async function assignDriver(orderId: string, driverId: string): Promise<void> {
  console.log('Assigning driver to order:', { orderId, driverId });
  
  // Get order details first
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select('customer_id, order_number')
    .eq('id', orderId)
    .single();

  if (orderError) {
    console.error('Error fetching order:', orderError);
    throw orderError;
  }

  const { error } = await supabase
    .from('orders')
    .update({ 
      driver_id: driverId,
      status: 'accepted',
      confirmed_at: new Date().toISOString(),
    })
    .eq('id', orderId);

  if (error) {
    console.error('Error assigning driver:', error);
    throw error;
  }

  console.log('Driver assigned successfully');

  // Update chat with driver
  const { error: chatError } = await supabase
    .from('chats')
    .update({ driver_id: driverId })
    .eq('order_id', orderId);

  if (chatError) {
    console.error('Error updating chat:', chatError);
  }

  // Invalidate caches
  await AsyncStorage.removeItem(`orders_${order.customer_id}`);
  await AsyncStorage.removeItem(`driver_orders_${driverId}`);
  await AsyncStorage.removeItem('admin_orders_cache');
  console.log('ðŸ§¹ Invalidated order caches');

  // Broadcast order update
  await supabase.channel(`orders:${orderId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { orderId, status: 'accepted', driverId },
  });
  
  console.log('Order update broadcasted');
}

export async function updateOrderStatus(orderId: string, status: OrderStatus): Promise<void> {
  console.log('Updating order status:', { orderId, status });
  
  // Get order details first
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select('customer_id, order_number, driver_id')
    .eq('id', orderId)
    .single();

  if (orderError) {
    console.error('Error fetching order:', orderError);
    throw orderError;
  }

  const updateData: any = { 
    status,
    updated_at: new Date().toISOString(),
  };

  // Add timestamp fields based on status
  if (status === 'picked_up') {
    updateData.picked_up_at = new Date().toISOString();
  } else if (status === 'delivered') {
    updateData.delivered_at = new Date().toISOString();
  } else if (status === 'cancelled') {
    updateData.cancelled_at = new Date().toISOString();
  }

  const { error } = await supabase
    .from('orders')
    .update(updateData)
    .eq('id', orderId);

  if (error) {
    console.error('Error updating order status:', error);
    throw error;
  }

  console.log('Order status updated successfully');

  // Invalidate caches
  await AsyncStorage.removeItem(`orders_${order.customer_id}`);
  if (order.driver_id) {
    await AsyncStorage.removeItem(`driver_orders_${order.driver_id}`);
  }
  await AsyncStorage.removeItem('admin_orders_cache');
  console.log('ðŸ§¹ Invalidated order caches');

  // Broadcast order update
  await supabase.channel(`orders:${orderId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { orderId, status },
  });
  
  console.log('Order update broadcasted');
}

// Cancel order by driver - resets to pending
export async function cancelOrderByDriver(orderId: string): Promise<void> {
  console.log('Driver cancelling order:', orderId);
  
  const { error } = await supabase
    .from('orders')
    .update({ 
      driver_id: null,
      status: 'pending',
      updated_at: new Date().toISOString(),
    })
    .eq('id', orderId);

  if (error) {
    console.error('Error cancelling order:', error);
    throw error;
  }

  console.log('Order cancelled and reset to pending');

  // Broadcast order update
  await supabase.channel(`orders:${orderId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { orderId, status: 'pending', driverId: null },
  });
}

// Search orders by order number, customer name, or address
export async function searchOrders(query: string): Promise<Order[]> {
  console.log('Searching orders with query:', query);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .or(`order_number.ilike.%${query}%,delivery_address.ilike.%${query}%`)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error searching orders:', error);
    throw error;
  }
  
  console.log('Search results:', data?.length || 0);
  return data || [];
}

// Filter orders by status
export async function filterOrdersByStatus(status: OrderStatus): Promise<Order[]> {
  console.log('Filtering orders by status:', status);
  
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      customer:users!orders_customer_id_fkey(id, name, email, phone),
      driver:users!orders_driver_id_fkey(id, name, email, phone),
      store:stores(id, name, address, phone, logo)
    `)
    .eq('status', status)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error filtering orders:', error);
    throw error;
  }
  
  console.log('Filtered orders:', data?.length || 0);
  return data || [];
}
