
import { supabase } from '../config/supabase';
import { Errand, ErrandCategory, ErrandSubcategory, ErrandStatus, ErrandDocument, ErrandStatusUpdate } from '../types/errand.types';

export async function getErrandCategories(): Promise<ErrandCategory[]> {
  const { data, error } = await supabase
    .from('errand_categories')
    .select('*')
    .eq('is_active', true)
    .order('display_order', { ascending: true });

  if (error) {
    console.error('Error fetching errand categories:', error);
    throw error;
  }
  return data || [];
}

export async function getErrandSubcategories(categoryId?: string): Promise<ErrandSubcategory[]> {
  let query = supabase
    .from('errand_subcategories')
    .select('*')
    .eq('is_active', true);

  if (categoryId) {
    query = query.eq('category_id', categoryId);
  }

  const { data, error } = await query.order('display_order', { ascending: true });

  if (error) {
    console.error('Error fetching errand subcategories:', error);
    throw error;
  }
  return data || [];
}

export async function createErrand(errandData: {
  customerId: string;
  categoryId: string;
  subcategoryId: string;
  pickupAddress: string;
  pickupLatitude?: number;
  pickupLongitude?: number;
  dropoffAddress: string;
  dropoffLatitude?: number;
  dropoffLongitude?: number;
  instructions?: string;
  notes?: string;
  customDescription?: string;
  scheduledTime?: string;
  isAsap?: boolean;
  basePrice: number;
  distanceFee: number;
  complexityFee: number;
  totalPrice: number;
  paymentMethod: 'cash' | 'card' | 'mobile_money' | 'bank_transfer';
}): Promise<Errand> {
  console.log('Creating errand with data:', errandData);

  // Build insert data
  const insertData: any = {
    customer_id: errandData.customerId,
    category_id: errandData.categoryId,
    subcategory_id: errandData.subcategoryId,
    pickup_address: errandData.pickupAddress,
    dropoff_address: errandData.dropoffAddress,
    instructions: errandData.instructions,
    notes: errandData.notes,
    custom_description: errandData.customDescription,
    scheduled_time: errandData.scheduledTime,
    is_asap: errandData.isAsap ?? true,
    base_price: errandData.basePrice,
    distance_fee: errandData.distanceFee,
    complexity_fee: errandData.complexityFee,
    total_price: errandData.totalPrice,
    payment_method: errandData.paymentMethod,
    payment_status: 'pending',
    status: 'pending',
  };

  // Add coordinates if provided
  if (errandData.pickupLatitude !== undefined && errandData.pickupLongitude !== undefined) {
    insertData.pickup_latitude = errandData.pickupLatitude;
    insertData.pickup_longitude = errandData.pickupLongitude;
  }
  if (errandData.dropoffLatitude !== undefined && errandData.dropoffLongitude !== undefined) {
    insertData.dropoff_latitude = errandData.dropoffLatitude;
    insertData.dropoff_longitude = errandData.dropoffLongitude;
  }

  // Errand number will be auto-generated by trigger
  const { data: errand, error: errandError } = await supabase
    .from('errands')
    .insert(insertData)
    .select()
    .single();

  if (errandError) {
    console.error('Error creating errand:', errandError);
    throw errandError;
  }

  console.log('Errand created:', errand);
  return errand;
}

export async function getErrandById(errandId: string): Promise<Errand> {
  const { data, error } = await supabase
    .from('errands')
    .select(`
      *,
      customer:users!errands_customer_id_fkey(id, name, email, phone),
      runner:users!errands_runner_id_fkey(id, name, email, phone),
      category:errand_categories(id, name, icon),
      subcategory:errand_subcategories(id, name, description, estimated_time)
    `)
    .eq('id', errandId)
    .single();

  if (error) {
    console.error('Error fetching errand:', error);
    throw error;
  }
  return data;
}

export async function getErrandsByCustomer(customerId: string): Promise<Errand[]> {
  const { data, error } = await supabase
    .from('errands')
    .select(`
      *,
      category:errand_categories(id, name, icon),
      subcategory:errand_subcategories(id, name, description),
      runner:users!errands_runner_id_fkey(id, name, phone)
    `)
    .eq('customer_id', customerId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching customer errands:', error);
    throw error;
  }
  
  console.log('Customer errands fetched:', data?.length || 0);
  return data || [];
}

export async function getErrandsByRunner(runnerId: string): Promise<Errand[]> {
  const { data, error } = await supabase
    .from('errands')
    .select(`
      *,
      customer:users!errands_customer_id_fkey(id, name, email, phone),
      category:errand_categories(id, name, icon),
      subcategory:errand_subcategories(id, name, description)
    `)
    .eq('runner_id', runnerId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching runner errands:', error);
    throw error;
  }
  return data || [];
}

export async function getPendingErrands(): Promise<Errand[]> {
  const { data, error } = await supabase
    .from('errands')
    .select(`
      *,
      customer:users!errands_customer_id_fkey(id, name, email, phone),
      category:errand_categories(id, name, icon),
      subcategory:errand_subcategories(id, name, description)
    `)
    .eq('status', 'pending')
    .is('runner_id', null)
    .order('created_at', { ascending: true });

  if (error) {
    console.error('Error fetching pending errands:', error);
    throw error;
  }
  return data || [];
}

export async function assignRunner(errandId: string, runnerId: string): Promise<void> {
  const { error } = await supabase
    .from('errands')
    .update({ 
      runner_id: runnerId,
      status: 'accepted',
      accepted_at: new Date().toISOString(),
    })
    .eq('id', errandId);

  if (error) {
    console.error('Error assigning runner:', error);
    throw error;
  }

  // Broadcast errand update
  await supabase.channel(`errands:${errandId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { errandId, status: 'accepted', runnerId },
  });
}

export async function updateErrandStatus(errandId: string, status: ErrandStatus): Promise<void> {
  const updateData: any = { 
    status,
    updated_at: new Date().toISOString(),
  };

  // Add timestamp fields based on status
  if (status === 'accepted') {
    updateData.accepted_at = new Date().toISOString();
  } else if (status === 'at_pickup') {
    updateData.at_pickup_at = new Date().toISOString();
  } else if (status === 'pickup_complete') {
    updateData.pickup_complete_at = new Date().toISOString();
  } else if (status === 'en_route') {
    updateData.en_route_at = new Date().toISOString();
  } else if (status === 'completed') {
    updateData.completed_at = new Date().toISOString();
  } else if (status === 'cancelled') {
    updateData.cancelled_at = new Date().toISOString();
  }

  const { error } = await supabase
    .from('errands')
    .update(updateData)
    .eq('id', errandId);

  if (error) {
    console.error('Error updating errand status:', error);
    throw error;
  }

  // Broadcast errand update
  await supabase.channel(`errands:${errandId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { errandId, status },
  });
}

// Cancel errand by driver - resets to pending
export async function cancelErrandByDriver(errandId: string): Promise<void> {
  console.log('Driver cancelling errand:', errandId);
  
  const { error } = await supabase
    .from('errands')
    .update({ 
      runner_id: null,
      status: 'pending',
      updated_at: new Date().toISOString(),
    })
    .eq('id', errandId);

  if (error) {
    console.error('Error cancelling errand:', error);
    throw error;
  }

  console.log('Errand cancelled and reset to pending');

  // Broadcast errand update
  await supabase.channel(`errands:${errandId}`).send({
    type: 'broadcast',
    event: 'UPDATE',
    payload: { errandId, status: 'pending', runnerId: null },
  });
}

export async function uploadErrandDocument(
  errandId: string,
  file: File | Blob,
  documentType: 'receipt' | 'authorization' | 'photo' | 'other',
  userId: string
): Promise<ErrandDocument> {
  // Upload file to Supabase Storage
  const fileName = `${errandId}/${Date.now()}_${documentType}`;
  const { data: uploadData, error: uploadError } = await supabase.storage
    .from('errand-documents')
    .upload(fileName, file);

  if (uploadError) {
    console.error('Error uploading document:', uploadError);
    throw uploadError;
  }

  // Get public URL
  const { data: { publicUrl } } = supabase.storage
    .from('errand-documents')
    .getPublicUrl(fileName);

  // Save document record
  const { data: document, error: documentError } = await supabase
    .from('errand_documents')
    .insert({
      errand_id: errandId,
      document_type: documentType,
      file_url: publicUrl,
      file_name: fileName,
      uploaded_by: userId,
    })
    .select()
    .single();

  if (documentError) {
    console.error('Error saving document record:', documentError);
    throw documentError;
  }

  return document;
}

export async function getErrandDocuments(errandId: string): Promise<ErrandDocument[]> {
  const { data, error } = await supabase
    .from('errand_documents')
    .select('*')
    .eq('errand_id', errandId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching errand documents:', error);
    throw error;
  }
  return data || [];
}

/**
 * FIXED PRICING: All errands are now $2000 GYD flat rate
 * No distance fees, no complexity fees
 */
export function calculateErrandPrice(
  basePrice: number,
  distance: number, // in km (not used anymore)
  complexity: 'low' | 'medium' | 'high' = 'low' // not used anymore
): { basePrice: number; serviceFee: number; distanceFee: number; complexityFee: number; totalPrice: number } {
  // FIXED PRICING: $2000 GYD for all errands
  const fixedTotalPrice = 2000;
  
  return {
    basePrice: fixedTotalPrice,
    serviceFee: 0,
    distanceFee: 0,
    complexityFee: 0,
    totalPrice: fixedTotalPrice,
  };
}

export async function getErrandStatusUpdates(errandId: string): Promise<ErrandStatusUpdate[]> {
  const { data, error } = await supabase
    .from('errand_status_updates')
    .select('*')
    .eq('errand_id', errandId)
    .order('timestamp', { ascending: false });

  if (error) {
    console.error('Error fetching errand status updates:', error);
    throw error;
  }
  return data || [];
}

export async function createErrandStatusUpdate(
  errandId: string,
  runnerId: string | null,
  status: ErrandStatus,
  notes?: string
): Promise<ErrandStatusUpdate> {
  const { data, error } = await supabase
    .from('errand_status_updates')
    .insert({
      errand_id: errandId,
      runner_id: runnerId,
      status,
      notes,
      timestamp: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating errand status update:', error);
    throw error;
  }
  return data;
}
